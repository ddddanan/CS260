# -*- coding: utf-8 -*-
"""loss-rtt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C_2p0dcrFakutC88lcjYekVN8XdE9jj3
"""

from google.colab import drive
drive.mount('/content/drive')

import os
from collections import Counter

def parse_log(file_path):
    data = Counter()
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split(',')
            seq = int(parts[0].split(':')[-1].strip())
            data[seq] += 1
    return data

def analyze_logs(sender_log, receiver_log):
    sender_data = parse_log(sender_log)
    receiver_data = parse_log(receiver_log)

    total_loss = 0

    # Calculate packet loss for each sequence number
    for seq, count in sender_data.items():
        received_count = receiver_data[seq] if seq in receiver_data else 0
        if count > received_count:
            loss_count = count - received_count
            total_loss += loss_count
            print(f"Seq {seq}: Sent {count}, Received {received_count}, Loss {loss_count}")

    # Summary of total packet loss
    print(f"Total Lost Packets: {total_loss}")

# Paths to the log files on Google Drive
sender_log_path = '/content/drive/My Drive/project/serverc.log'  # Update the path
receiver_log_path = '/content/drive/My Drive/project/clientc.log'  # Update the path

analyze_logs(sender_log_path, receiver_log_path)

from google.colab import drive
import re
import pandas as pd
import matplotlib.pyplot as plt

# 读取日志文件
file_path = '/content/drive/My Drive/project/5kb/119/client.log'
with open(file_path, 'r') as file:
    log_data = file.readlines()

# 解析数据
pattern = r'Seq: (\d+), Sent: (\d+), Received: (\d+)'
data = []

for line in log_data:
    match = re.match(pattern, line)
    if match:
        seq, sent, received = match.groups()
        sent, received = int(sent), int(received)
        data.append((seq, sent, received))

# 创建DataFrame
df = pd.DataFrame(data, columns=['Seq', 'Sent', 'Received'])

# 计算时间差
df['Time_Diff'] = df['Received'] - df['Sent']

# 绘制图表
plt.figure(figsize=(10, 6))
plt.plot(df['Sent'], df['Time_Diff'], marker='o')
plt.xlabel('Sent Timestamp')
plt.ylabel('Time Difference (ms)')
plt.title('Time Difference between Sent and Received Timestamps')
plt.grid(True)
plt.show()

# 计算统计数据
min_diff = df['Time_Diff'].min()
max_diff = df['Time_Diff'].max()
mean_diff = df['Time_Diff'].mean()

print(f'Minimum Time Difference: {min_diff} ms')
print(f'Maximum Time Difference: {max_diff} ms')
print(f'Average Time Difference: {mean_diff:.2f} ms')

pip install pandas

import pandas as pd

# 定义一个函数来解析日志文件
def parse_log_file(file_path):
    log_entries = []
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split(', ')
            seq = int(parts[0].split(': ')[1])
            sent = int(parts[1].split(': ')[1])
            received = int(parts[2].split(': ')[1])
            log_entries.append({'Seq': seq, 'Sent': sent, 'Received': received})
    return pd.DataFrame(log_entries)

# 读取日志文件
log_df = parse_log_file('/content/drive/My Drive/project/5kb/118/client.log')

# 计算传输延迟
log_df['Transmission_Delay'] = log_df['Received'].diff()

# 计算RTT
log_df['RTT'] = log_df['Received'] - log_df['Sent']

# 计算最小RTT
rtt_min = log_df['RTT'].min()

# 计算队列延迟的下界
log_df['Queueing_Delay_Lower_Bound'] = log_df['RTT'] - rtt_min - log_df['Transmission_Delay']

# 计算队列长度
def calculate_queue_lengths(df):
    queue_lengths = []
    for i in range(1, len(df)):
        lower_bound = df.loc[i, 'Queueing_Delay_Lower_Bound']
        ni = 0
        for ni in range(i):
            sum_tk = df.loc[i-ni:i-1, 'Transmission_Delay'].sum()
            if sum_tk >= lower_bound:
                break
        queue_lengths.append(ni)
    return queue_lengths

log_df['Queue_Length'] = [0] + calculate_queue_lengths(log_df)

# 计算最大缓冲区大小
max_queue_length = log_df['Queue_Length'].max()
if max_queue_length > 0:
    buffer_size_estimate = max_queue_length + 1
else:
    buffer_size_estimate = max_queue_length

# 假设每个数据包大小为1024字节
packet_size_bytes = 1024

# 将缓冲区大小转换为千字节
buffer_size_kb = buffer_size_estimate * packet_size_bytes / 1024

# 打印结果
print("Transmission Delays:", log_df['Transmission_Delay'].tolist())
print("RTTs:", log_df['RTT'].tolist())
print("Minimum RTT:", rtt_min)
print("Queueing Delay Lower Bounds:", log_df['Queueing_Delay_Lower_Bound'].tolist())
print("Queue Lengths:", log_df['Queue_Length'].tolist())
num=0
for i in range(1, len(log_df['Queue_Length'])):
  if(log_df['Queue_Length'][i]>=4):
    num+=1;
print(num)
print("Estimated Maximum Buffer Size (L'):", buffer_size_estimate)
print("Estimated Maximum Buffer Size (KB):", buffer_size_kb)

from google.colab import drive
import re
import pandas as pd
import matplotlib.pyplot as plt

# 挂载 Google Drive
drive.mount('/content/drive')

def parse_server_log(file_path):
    data = {}
    with open(file_path, 'r') as file:
        log_data = file.readlines()
    pattern = r'(\d+),(\d+)'  # 匹配 server.log 的格式
    for line in log_data:
        match = re.match(pattern, line)
        if match:
            seq, timestamp = match.groups()
            seq = int(seq)
            timestamp = int(timestamp)
            if seq in data:
                data[seq].append(timestamp)
            else:
                data[seq] = [timestamp]
    return data

def parse_client_log(file_path):
    data = {}
    with open(file_path, 'r') as file:
        log_data = file.readlines()
    pattern = r'Seq: (\d+), Sent: (\d+), Received: (\d+)'  # 匹配 client.log 的格式
    for line in log_data:
        match = re.match(pattern, line)
        if match:
            seq, sent, received = match.groups()
            seq = int(seq)
            sent = int(sent)
            received = int(received)
            if seq in data:
                data[seq].append((sent, received))
            else:
                data[seq] = [(sent, received)]
    return data

# 路径更新为示例路径，实际使用时需要修改
server_log_path = '/content/drive/My Drive/project/5kb/118/server.log'
client_log_path = '/content/drive/My Drive/project/5kb/118/client.log'

server_data = parse_server_log(server_log_path)
client_data = parse_client_log(client_log_path)

time_diff_data = []

# 计算时间差或标记丢包
for seq, sent_timestamps in server_data.items():
    received_data = client_data.get(seq, [])
    sent_count = len(sent_timestamps)
    received_count = len(received_data)

    for i in range(max(sent_count, received_count)):
        if i < sent_count:
            sent_timestamp = sent_timestamps[i]
            if i < received_count:
                sent, received = received_data[i]
                time_diff = received - sent  # 修正为正确的时间差计算
                time_diff_data.append((seq, sent_timestamp, time_diff))
            else:
                # 丢包情况
                time_diff_data.append((seq, sent_timestamp, 100))
        else:
            # 对于 server.log 中没有的情况（一般不会发生），我们可以忽略
            pass

# 创建 DataFrame
df = pd.DataFrame(time_diff_data, columns=['Seq', 'Sent_Timestamp', 'Time_Diff'])

# 打印调试信息
print("DataFrame 内容：")
print(df)

# 绘制图表
plt.figure(figsize=(10, 6))
plt.plot(df['Sent_Timestamp'], df['Time_Diff'], marker='o')
plt.xlabel('Sent Timestamp')
plt.ylabel('Time Difference (ms)')
plt.title('Time Difference between Sent and Received Timestamps (with Packet Loss)')
plt.grid(True)
plt.show()

# 计算统计数据
min_diff = df['Time_Diff'][df['Time_Diff'] != 100].min()
max_diff = df['Time_Diff'][df['Time_Diff'] != 100].max()
mean_diff = df['Time_Diff'][df['Time_Diff'] != 100].mean()

print(f'Minimum Time Difference: {min_diff} ms')
print(f'Maximum Time Difference: {max_diff} ms')
print(f'Average Time Difference: {mean_diff:.2f} ms')

import matplotlib.pyplot as plt
import numpy as np

# 数据
packets_per_second = [50, 100, 115, 125, 1000, 10000]
max_min_buffers = [1.46484, 1.2207, 1.58691, 2.0752, 2.56348, 3.17383]
sod_buffers_before_115 = [0.0, 0.0]  # 115之前的SOD值
sod_buffers_at_115 = [0.0, 2.0]  # 115的SOD值
sod_buffers_after_115 = [2.0, 2.0, 2.0]  # 115之后的SOD值
tc_actual_buffersize = 2.0  # 实际设置的buffersize

# 定义自定义的x轴位置，使得115在中间
x_positions_before_115 = [0, 1]  # 115之前的x位置
x_positions_at_115 = [1, 2]  # 100到115的x位置
x_positions_after_115 = [2, 3, 5, 6]  # 115之后的x位置

# 创建图表
plt.figure(figsize=(12, 6))

# 绘制max-min算法的曲线
plt.plot(x_positions_before_115 + [2] + x_positions_after_115[1:], max_min_buffers, label='Max-Min Algorithm', marker='o')

# 绘制sod算法的三段直线
plt.plot(x_positions_before_115, sod_buffers_before_115, label='SOD Algorithm', marker='s', color='tab:orange')
plt.plot([1, 2], [0.0, 0.0], color='tab:orange')  # 从100到115的水平线
plt.plot([2, 2], [0.0, 2.0], color='tab:orange')  # 115处的垂直线
plt.plot([2] + x_positions_after_115[1:], [2.0] + sod_buffers_after_115, marker='s', linestyle='--', color='tab:orange')

# 绘制实际设置的buffersize的水平线
plt.axhline(y=tc_actual_buffersize, color='r', linestyle='--', label='TC Actual Buffersize')

# 设置x轴刻度和标签
plt.xticks(x_positions_before_115 + [2] + x_positions_after_115[1:], packets_per_second)

# 添加图例和标签
plt.xlabel('Packets/s')
plt.ylabel('Buffer Size (KB)')
plt.title('Estimated Buffer Size Comparison')
plt.legend()

# 显示网格
plt.grid(True)

# 显示图表
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# 数据
packets_per_second = [100, 115, 116, 117, 118, 119, 120, 125, 150, 1000]
max_min_buffers = [1.46484, 1.2207, 1.46484, 2.0752, 5.12695, 5.12695, 5.24902, 5.12695, 5.24902, 5.37109]
sod_buffers = [0.0, 2.0, 2.0, 2.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]
tc_actual_buffersize = 5.0  # 实际设置的buffersize

# 自定义x轴位置，使得115到120的范围较小，150到1000的范围较小
x_positions = [0, 1, 1.5, 2, 2.5, 3, 3.5, 5, 7, 9]

# 创建图表
plt.figure(figsize=(12, 6))

# 绘制Max-Min算法的曲线
plt.plot(x_positions, max_min_buffers, label='Max-Min Algorithm', marker='o')

# 绘制SOD算法的曲线
plt.plot(x_positions, sod_buffers, label='SOD Algorithm', marker='s')

# 绘制实际设置的buffersize的水平线
plt.axhline(y=tc_actual_buffersize, color='r', linestyle='--', label='TC Actual Buffersize')

# 设置x轴刻度和标签，突出显示118
plt.xticks(x_positions, packets_per_second)

# 手动更改118的位置颜色
ax = plt.gca()
xticks = ax.get_xticklabels()
xticks[4].set_color('blue')

# 添加图例和标签
plt.xlabel('Packets/s')
plt.ylabel('Buffer Size (KB)')
plt.title('Estimated Buffer Size Comparison')
plt.legend()

# 显示网格
plt.grid(True)

# 显示图表
plt.show()